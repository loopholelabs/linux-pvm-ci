From: bysui <a971379855@gmail.com>
Subject: https://github.com/virt-pvm/linux/issues/7#issuecomment-2069445537
---
diff --git a/arch/x86/kvm/x86.c b/arch/x86/kvm/x86.c
index 29413cb2f..aa819f664 100644
--- a/arch/x86/kvm/x86.c
+++ b/arch/x86/kvm/x86.c
@@ -5517,12 +5517,20 @@ static void kvm_vcpu_ioctl_x86_get_xsave2(struct kvm_vcpu *vcpu,
 	 */
 	u64 supported_xcr0 = vcpu->arch.guest_supported_xcr0 |
 			     XFEATURE_MASK_FPSSE;
+	union fpregs_state *ustate = (void *)state;
 
 	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))
 		return;
 
 	fpu_copy_guest_fpstate_to_uabi(&vcpu->arch.guest_fpu, state, size,
 				       supported_xcr0, vcpu->arch.pkru);
+
+	pr_info("during getting:\n guest xcr0: %llx, host xcr0: %llx, supported_xcr0: %llx\n",
+	        vcpu->arch.xcr0, host_xcr0, supported_xcr0);
+	pr_info("guest pkru: %x, host pkru: %x\n",
+	        vcpu->arch.pkru, vcpu->arch.host_pkru);
+	pr_info("xfeatures: %llx, xcomp_bv: %llx\n",
+        ustate->xsave.header.xfeatures, ustate->xsave.header.xcomp_bv);
 }
 
 static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
@@ -5535,9 +5543,18 @@ static void kvm_vcpu_ioctl_x86_get_xsave(struct kvm_vcpu *vcpu,
 static int kvm_vcpu_ioctl_x86_set_xsave(struct kvm_vcpu *vcpu,
 					struct kvm_xsave *guest_xsave)
 {
+	union fpregs_state *ustate = (void *)guest_xsave->region;
+
 	if (fpstate_is_confidential(&vcpu->arch.guest_fpu))
 		return 0;
 
+	pr_info("during settting:\n guest xcr0: %llx, host xcr0: %llx, supported_xcr0: %llx\n",
+	        vcpu->arch.xcr0, host_xcr0, kvm_caps.supported_xcr0);
+	pr_info("guest pkru: %x, host pkru: %x\n",
+	        vcpu->arch.pkru, vcpu->arch.host_pkru);
+	pr_info("xfeatures: %llx, xcomp_bv: %llx\n",
+        ustate->xsave.header.xfeatures, ustate->xsave.header.xcomp_bv);
+
 	return fpu_copy_uabi_to_guest_fpstate(&vcpu->arch.guest_fpu,
 					      guest_xsave->region,
 					      kvm_caps.supported_xcr0,
diff --git a/arch/x86/mm/extable.c b/arch/x86/mm/extable.c
index 271dcb2de..b2e280172 100644
--- a/arch/x86/mm/extable.c
+++ b/arch/x86/mm/extable.c
@@ -6,6 +6,7 @@
 #include <xen/xen.h>
 
 #include <asm/fpu/api.h>
+#include <asm/fpu/xcr.h>
 #include <asm/sev.h>
 #include <asm/traps.h>
 #include <asm/kdebug.h>
@@ -121,8 +122,18 @@ static bool ex_handler_sgx(const struct exception_table_entry *fixup,
 static bool ex_handler_fprestore(const struct exception_table_entry *fixup,
 				 struct pt_regs *regs)
 {
+	static bool once;
 	regs->ip = ex_fixup_addr(fixup);
 
+	if (boot_cpu_has(X86_FEATURE_XSAVE) && !once) {
+        struct xregs_state *state = (void *)regs->di;
+
+        once = true;
+        pr_info("xcr0 is %llx\n", xgetbv(XCR_XFEATURE_ENABLED_MASK));
+        pr_info("xfeatures: %llx, xcomp_bv: %llx\n",
+                state->header.xfeatures, state->header.xcomp_bv);
+    }
+
 	WARN_ONCE(1, "Bad FPU state detected at %pB, reinitializing FPU registers.",
 		  (void *)instruction_pointer(regs));
 
